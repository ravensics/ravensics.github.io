---
title: "TISC 2023 Write Up (Challenges 1-6)"
date: 2023-10-07
categories:
  - CTF
tags:
  - CTF
  - Forensics
  - Crypto
  - Mobile
  - OSINT
  - Web
toc: true
toc_label: "Table of Contents"
toc_icon: "cog"
toc_sticky: "true"
comments: true
---

TISC 2023 was a Capture-the-Flag (CTF) competition organised by CSIT where there were 10 challenges of various topics from Forensics, Mobile, Web etc. 

I managed to complete challenges 1-6 and the write ups for each challenge are written below. Enjoy!

***
# 1. Disk Archaelogy
Domain(s): Forensics

![4d18338b1d831948e39d5b7c107fd4b6.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/4d18338b1d831948e39d5b7c107fd4b6.png)

> This challenge was a Forensics challenge where we were given a *challenge.tar.xz* file.

## Partial Flag

Using *7zip* to decompress the file, a file *challenge.img* was extracted, which was an **ext4** disk image. 
Using *HxD* to search for the string `TISC`, what seemed like the flag was easily obtained:

![34dac8a83652a85de11a0e97f4a6fd96.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/34dac8a83652a85de11a0e97f4a6fd96.png)

However, this was not the full flag, as there was a %s format specifier. From the front part of the flag, which read 'was there something left', this hinted that there was something left behind, i.e. a deleted file that still remained in the system.

## File Carving

To obtain the full flag, photorec was run on the unallocated space of the disk image to verify if any files could be carved:

![307147c3c808523684bcbe45a8a6dff5.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/307147c3c808523684bcbe45a8a6dff5.png)

![6193a7f865bff1cde5d17126fd56d696.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/6193a7f865bff1cde5d17126fd56d696.png)

![49370bd8c2f6a225264faf1709d98fbc.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/49370bd8c2f6a225264faf1709d98fbc.png)

![24854520e0dc82cf3d90185196d1ffa0.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/24854520e0dc82cf3d90185196d1ffa0.png)

![868a797a322ca6e86b349e78843a087d.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/868a797a322ca6e86b349e78843a087d.png)

![1879db91d5a140087cbebecd24b52fff.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/1879db91d5a140087cbebecd24b52fff.png)

1 file was recovered, and the recovered file was an ELF file:

![bf4f6b065f8978b4299bc0cec776862a.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/bf4f6b065f8978b4299bc0cec776862a.png)

## Running of Executable

However, even after enabling execution of the file, the file could not be executed:

![a2209fb25e0e931a4c2f2d57c038b342.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/a2209fb25e0e931a4c2f2d57c038b342.png)
![43a82be34918cd1ae0833a17669796ac.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/43a82be34918cd1ae0833a17669796ac.png)

Using the command `file f1315992.elf` to analyse the file, it was revealed that a non-typical interpreter was required, */lib/ld-musl-x86_64.so.1*:

![a4a7b8ebbd43a7f63cdbfb42ec813f16.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/a4a7b8ebbd43a7f63cdbfb42ec813f16.png)

After installing package *musl*, the file could then be run and the full flag was obtained:

![02a8fefab70e6edfc94528c426cbcc39.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/02a8fefab70e6edfc94528c426cbcc39.png)
<br>

***
# 2. XIPHEREHPIX's Reckless Mistake
Domain(s): Crypto

![c95f22852ef6e33c57d33313b345f868.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/c95f22852ef6e33c57d33313b345f868.png)

> This challenge was a Crypto challenge where we were given 2 files: an ELF file 'XIPHEREHPIX' as well its source code, 'prog.c'.

## Testing the Program

Upon executing the ELF file, we were prompted to key in a password which is at least 40 characters long:

![83c74e60e2d5d1ce3c5f4b7aeb043111.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/83c74e60e2d5d1ce3c5f4b7aeb043111.png)

Typing a random password of over 40 characters will result in 'Failure':

![20e8b417f3c13f71d9c56cf1b5c330d5.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/20e8b417f3c13f71d9c56cf1b5c330d5.png)

## Understanding the Program Execution Flow

Looking at the source code, the *main()* function was as follows:
```cpp
int main(int argc, char **argv)
{
    char password[MAX_PASSWORD_SIZE + 1] = { 0 };
    int password_length;

    unsigned char key[32];

    printf("Hello PALINDROME member, please enter password:");

    password_length = input_password(password);
    if (password_length < 40) {
        printf("The password should be at least 40 characters as per PALINDROME's security policy.\n");
        exit(0);
    }

    if (!verify_password(password, password_length)) {
        initialise_key(key, password, password_length);
        show_welcome_msg(key);
    }
        
    else {
        printf("Failure! \n");
        exit(0);
    }
}
```

This program could have been broken down into multiple steps, where:
1. The password was checked in 2 ways:
a. Password length had to be >40
b. Password was passed through a *verify_password()* function which checks the hash of the password against a hardcoded SHA256 hash:
```cpp
uint64_t hash[] = { 0x962fe02a147163af,
					0x8003eb5b7ff75652,
					0x3220981f9f027e35,
					0xfb933faadd7944b7};
```

2. A key was initialised based off the correct expected password

3. The key was then used to decrypt an encrypted blob and display the welcome message, containing the flag

```cpp
void show_welcome_msg(unsigned char *key) {
    int plaintext_length;
    unsigned char *iv = "PALINDROME ROCKS";
    
    unsigned char plaintext[128] = { 0 };
    const unsigned char * const header = "welcome_message";
    unsigned char ciphertext[] =
        "\xad\xac\x81\x20\xc6\xd5\xb1\xb8\x3a\x2a\xa8\x54\xe6\x5f\x9a\xad"
        "\xa4\x39\x05\xd9\x21\xae\xab\x50\x98\xbd\xe4\xc8\xe8\x2a\x3c\x63"
        "\x82\xe3\x8e\x5d\x79\xf0\xc6\xf4\xf2\xe7";

    unsigned char tag[] =
        "\xbd\xfc\xc0\xdb\xd9\x09\xed\x66\x37\x34\x75\x11\x75\xa2\x7a\xaf";

    plaintext_length = gcm_decrypt(ciphertext, 
                42,
                (unsigned char *)header,
                strlen(header),
                tag,
                key, 
                iv,
                16,
                plaintext);

    printf("Welcome PALINDROME member. Your secret message is %.*s\n", plaintext_length, plaintext);
}
```

##  Finding the Flaw in Key Generation 

It was observed from the *gcm_decrypt()* function that AES GCM was used to encrypt the flag. On first glance, it seemed like the IV *"PALINDROME ROCKS"* was hardcoded into the source code, which could potentially be vulnerable to attacks such as crib-dragging attacks or known-plaintext attacks. However, given that only 1 ciphertext was available, these attacks seemed to not be possible.

Furthermore, it was not possible to enumerate the correct password, as it had a minimum length of 40 which translated to a minimum of 320 bits, which could not be brute forced.

In that case, the next part of the code that was examined was the *initialise_key()* function, to analyse if there was any issue in the way keys were generated from passwords and if multiple passwords could generate the same key:
```cpp
void initialise_key(unsigned char *key, char *password, int password_length) {
    const char *seed = "PALINDROME IS THE BEST!";
    int i, j;
    int counter = 0;

    uint256_t *key256  = (uint256_t *)key;

    key256->a0 = 0;
    key256->a1 = 0;
    key256->a2 = 0;
    key256->a3 = 0;

    uint256_t arr[20] = { 0 };

    calculate_sha256((unsigned char *) arr, (unsigned char *) seed, strlen(seed));

    for (i = 1; i < 20; i++) {
        calculate_sha256((unsigned char *)(arr+i), (unsigned char *) (arr+i-1), 32);
    }

    for (i = 0; i < password_length; i++) {
        int ch = password[i];
        for (j = 0; j < 8; j++) {
            counter = counter % 20;

            if (ch & 0x1) {
                accumulate_xor(key256, arr+counter);
            }

            ch = ch >> 1;
            counter++;
        }
    }
}
```

Looking at the *initialise_key()* function, how it worked was:
- It first generated an array of 20 different SHA256 hashes, with the first element being the SHA256 hash of the seed, *"PALINDROME IS THE BEST"*, the second element being the SHA256 hash of the first element, and so on. 
	- To illustrate:
		```cmd
		arr[0]  = sha256(seed)
		arr[1]  = sha256(arr[0])
		arr[2]  = sha256(arr[1])
		...
		arr[19] = sha256(arr[18])
		```
- Next, for every character in the password submitted:
	- The character is first converted to a binary string
	- For every bit starting from the Least Significant Bit (LSB) that is '1', the *accumulate_xor()* function will be run, which XORs the current key (that is initialised as 0) with one of the elements of the array of 20 SHA256 hashes
		- This is based on the position of the bit, tracked by the variable *counter*
		- Since there are 8 bits, this means that the element that is XOR-ed ranges from array[0] to array[7] for the first character
		- However, given that the counter increases across every bit of the password and an operation is performed to take the modulo of 20 `counter = counter %20`, this meant that for the second character, subsequent intermediate keys will be XOR-ed with elements array[8] to array[15], then for the third character, array[16] to array[19] to array[0] to array[3] (since it wraps around after counter reaches 20), and so on. 
	- To illustrate:
	Take for example the first 4 characters of the password is 'ABCD', where each character translates to the following respective binary values and XOR operations:
		- A : 01000001
			- Bit 0 == '1':
			`counter = 0`
			`key_intermediate = arr[0]`
			- Bit 6 == '1':
			`counter = 6`
			`key_intermediate = arr[0]^arr[6]`
		- B : 01000010
			- Bit 1 == '1':
			`counter = 9`
			`key_intermediate = arr[0]^arr[6]^arr[9]`
			- Bit 6 == '1':
			`counter = 14`
			`key_intermediate = arr[0]^arr[6]^arr[9]^arr[14]`
		- C : 01000011
			- Bit 0 == '1':
			`counter = 16`
			`key_intermediate = arr[0]^arr[6]^arr[9]^arr[14]^arr[16]`
			- Bit 1 == '1':
			`counter = 17`
			`key_intermediate = arr[0]^arr[6]^arr[9]^arr[14]^arr[16]`
			- Bit 6 == '1':
			`counter = 2`
			`key_intermediate = arr[0]^arr[6]^arr[9]^arr[14]^arr[16]^arr[2]`
		- D : 01000100
			- Bit 2 == '1':
			`counter = 6`
			`key_intermediate = arr[0]^arr[6]^arr[9]^arr[14]^arr[16]^arr[2]^arr[6]`
			- Bit 6 == '1':
			`counter = 10`
			`key_intermediate = arr[0]^arr[6]^arr[9]^arr[14]^arr[16]^arr[2]^arr[6]^arr[10]`
	- After going through the 4 characters, the value of key_intermediate was obtained: `key_intermediate = arr[0]^arr[6]^arr[9]^arr[14]^arr[16]^arr[2]^arr[6]^arr[10]`. However, due to the properties of XOR, the 2 `^arr[6]` operations would cancel each other out, resulting in the intermediate key now being equal to: 
`key_intermediate = arr[0]^arr[9]^arr[14]^arr[16]^arr[2]^arr[10]` 
	- This was a major discovery, as the cancellation of XOR operations meant that going through all the characters, there were only $$ 2^{20} $$ possible keys that could be generated, as every element of the array of SHA256 hashes were either XOR-ed or not. Compared to $$ 2^{32} $$, this was a number that could easily be brute forced.

## Enumeration of All Possible Keys
Removing all password checks to enumerate through the first 3 characters of the password (but only 4 bits of the 3rd character)  the *main()* function of the *prog.c* code was modified to the following:
```cpp
int main(int argc, char **argv)
{
    char password[MAX_PASSWORD_SIZE + 1] = { 0 };
    int password_length;

    unsigned char key[32];

    char brutePassword[3];
    for (int i =0; i < 256; i++) {
        brutePassword[2] = i;
        for (int j =0; j < 256; j++) {
            brutePassword[1] = j;
            for (int k =0; k < 16; k++) {
                brutePassword[0] = k;
                printf("password used: %s\n", brutePassword);
                printf("Key is:");
                for (int i = 0; i < 32; i++) {
                    printf("%02x", key[i]);
                }
                printf("\n");
                initialise_key(key, brutePassword, 3);
                show_welcome_msg(key);
            }
        }
    } 
}
```
This would already enumerate through all possible combinations of keys generated, and this code was compiled to an ELF file and subquently ran, where all possible welcome messages were saved to another text file. Searching through the text file for the `TISC` string, the flag was found:

`TISC{K3ysP4ce_1s_t00_smol_d2g7d97agsd8yhr}`
<br>

***
# 3. KPA
Domain(s): Mobile

![7613a2020784f25c303fbf95a0aae140.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/7613a2020784f25c303fbf95a0aae140.png)

> This challenge was a Mobile challenge, where we were given an apk file, 'kpa.apk'.

## Fixing the APK
When attempting to use jadx to analyse the apk file, there were some errors experienced.

From the challenge prompt, it was mentioned that the **"*last few bytes got corrupted*"**.

With that, from a forensics standpoint, the first course of action was to look into the file structure of an apk file. 

![09539eed2107db0861a7c5d9af618040.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/09539eed2107db0861a7c5d9af618040.png)

This meant that the apk file was essentially just a zip file. Looking into the file structure of a zip file, there is a section known as the **"End of central directory record (EOCD)"**, which begins with the following signature: `0x06054b50`

![b3b8f786370e84e8bd102ed92f934bc0.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/b3b8f786370e84e8bd102ed92f934bc0.png)

Looking into the hex bytes of the apk file using HxD and searching for the hex string `50 4B 05 06` (reversed due to endian-ness), the EOCD was located:

![4586fbd91fdba647add8e8aa2223b912.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/4586fbd91fdba647add8e8aa2223b912.png)

From there, each section of the EOCD was matched to their respective descriptions:

| Section | Value (hex) |
| -- | :-: |
| Number of this disk | 00 00 |
| Disk where central directory starts | 00 00 | 
| Number of central directory records on this disk | D0 02 |
| Total number of central directory records | D0 02 | 
| Size of central directory (bytes) | 7D BC 00 00 |
| Offset of start of central directory, relative to start of archive | CB 50 2A 00 |
| Comment length | 0A 00 |
| Comment | Not present |

Looking at the challenge prompt once again, it was mentioned that **"*the file shouldn't have any comments in it*"**, hinting at the fact that the comment length should be equal to 0. The bytes were thus changed, and it could now be opened in `jadx`. Furthermore, a valid APK signature was found, indicating that the file was restored successfully:

![d55fed34df88a10d8de5e1dbd96bff64.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/d55fed34df88a10d8de5e1dbd96bff64.png)

## Searching through APK for the Flag
Searching through the entire sea of java code for the `TISC` string, it was located within the class *com.tisc.kappa.MainActivity()*, within the method *M()*: 

![13d794842e8f523b79aa0f4a7ceee94c.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/13d794842e8f523b79aa0f4a7ceee94c.png)

This function appeared to compare an input string with a string of a specific SHA1 hash value, and perform a series of operations before printing the flag if the correct string had been input.

Tracing where this method was called- the class *c()* was located, where it appeared to take in a string which was entered by the user:

![11819bb79d09b9a55844427e8cfeb5ca.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/11819bb79d09b9a55844427e8cfeb5ca.png)

Thus, this meant that the user had to enter the correct string in order to observe the correct flag being printed out.

However, this class *c()* was implemented in an *onResume()* method, where there were multiple lines of code performing different functions:

![c87ed1cfa38cb289d81bffa135bc28d9.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/c87ed1cfa38cb289d81bffa135bc28d9.png)

Before even reaching the *setOnClickListener()* method, it seemed like there were many checks in place.

Attempting to see this in action, an android VM was used where this apk was installed inside the VM, using the following commands:
```cmd
adb connect <IP address of android VM>
adb root
adb install kpa_fixed.apk
```

![b56f7a460310902b55610c3d937a64df.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/b56f7a460310902b55610c3d937a64df.png)

Running the apk, the following screen was shown:
![74816b8fea05f55496e18fde3ab63e10.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/74816b8fea05f55496e18fde3ab63e10.png)

## Hooking onto Methods using Frida

It appeared that the first check, *if (j1.b.e())*, returned true, thus this screen was shown. Attempting to bypass this screen, this method had to be hooked, thus [`frida`](https://github.com/frida/frida/releases) was used to accomplish this. 

The correct frida server had to be installed, so the OS of the android VM was checked:

![d4edb0d1f41845c971dbcdf69e2f1277.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/d4edb0d1f41845c971dbcdf69e2f1277.png)

![bee66f9512ed7cad2be530bfe55e0dd8.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/bee66f9512ed7cad2be530bfe55e0dd8.png)

After installing `frida`, the frida server had to be pushed into the android VM and then run, using the following commands:
```
adb push <path to frida server> /data/local/tmp/
adb shell /data/local/tmp/frida-server-16.1.4-android-x86_64 &
frida-ps -U
```

![c2c966dd50e0cb364c4befe44bac04f9.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/c2c966dd50e0cb364c4befe44bac04f9.png)

The process 'KaPpA' was found to be running, which corresponded to *kpa_fixed.apk*.

Now that the frida server was set up, the following code was run to bypass the first check:
```python
import frida, sys

jscode = """
Java.perform(() => {
  let b = Java.use("j1.b");
  b["e"].implementation = function () {
    console.log(`b.e is called`);
    let result = this["e"]();
    console.log(`b.e result=${result}`);
  return false;
};
});
"""

process = frida.get_usb_device().attach('KaPpA')
script = process.create_script(jscode)
print('[*] Running CTF')
script.load()
sys.stdin.read()
```

In this code, the method "*j1.b.e*" was hooked to return **false** instead of true, thus bypassing the error message. However, another check was performed, where this screen was now shown instead:

![3892cf13e5fe634222310c39144fbfc0.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/3892cf13e5fe634222310c39144fbfc0.png)

It appeared that this portion of code was responsible for this, with the condition *if (j1.a.a(packageManager) == 20)* returning true: 

![b4918423d52cbf0eb7bc9dcb59426e7d.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/b4918423d52cbf0eb7bc9dcb59426e7d.png)

Thus, once again, by hooking onto the method *j1.a.a* and returning 20, this check was bypassed as well, with the following java code added to the python code:
```java
let a = Java.use("j1.a");
a["a"].implementation = function (packageManager) {
    console.log(`a.a is called: packageManager=${packageManager}`);
    let result = this["a"](packageManager);
    console.log(`a.a result=${result}`);
    return 20;
};
});
```

![84e33c836a44adc83d42eff183d915b9.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/84e33c836a44adc83d42eff183d915b9.png)

Finally, the answer was really close, although we were asked to submit a string where "*The secret you seek was just written somewhere...*". This implied that a string was just printed, although we needed a way to actually print it to reveal what the string was.

Within the code, it appeared that just before the method *setOnClickListener* was called, the method *sw.a()* was run. Inspecting this method, it appeared that there was a string *css()*  which was present, although it seemed to be empty.
![4d4cafc65afdf987839f93f77ccbeff2.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/4d4cafc65afdf987839f93f77ccbeff2.png)
![0e33b8883c6cfd5bf1bf09e43a81792f.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/0e33b8883c6cfd5bf1bf09e43a81792f.png)

Nonetheless, once again using `frida`, the string *css()* was attempted to be printed, with the following java code added to the python code:
```java
let sw = Java.use("com.tisc.kappa.sw");
sw["css"].implementation = function () {
    console.log(`sw.css is called`);
    let result = this["css"]();
    console.log(`sw.css result=${result}`);
    return result;
```

And it was true that *sw.css* contained a string!

![ae708e6276313d19e7f11c67671288a6.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/ae708e6276313d19e7f11c67671288a6.png)

This 25 character string, "ArBraCaDabra?KAPPACABANA!" was submitted, revealing the flag for this challenge:
![6dbbc18fb445e1091e01300fb5904884.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/6dbbc18fb445e1091e01300fb5904884.png)
<br>

***
# 4. Really Unfair Battleships Game
Domain(s): Pwn, Misc

![c3a9be388571d8b98271f547817ea397.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/c3a9be388571d8b98271f547817ea397.png)

> This challenge was a Pwn, Misc challenge where we were tasked to achieve a 'FLAWLESS VICTORY' in a game known as the 'Really Unfair Battleships Game'.

## Playing the Game Normally
Upon running the game, there was a 16x16 grid of cells where 1 wrong click would immediately be followed by a *DEFEAT* screen:
![8d8f0d338300dd42e2e945f633f8f602.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/8d8f0d338300dd42e2e945f633f8f602.png)

![bc941f92e87cec4eea30a72729c8f71e.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/bc941f92e87cec4eea30a72729c8f71e.png)

## Discovering the Actual Executable

Inspecting the processes run using Task Manager, it was revealed that there were multiple processes with either the '*Really Unfair Battleships Game*' or '*rubg*' name.

![3faa9e386db1812d671cd30c80a38117.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/3faa9e386db1812d671cd30c80a38117.png)

Looking into the file location of these processes, it was revealed that the actual executable was created in a temp folder, and the original executable was actually just an installer:

![5f02199c549bbf2f358141ae868c895b.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/5f02199c549bbf2f358141ae868c895b.png)

Looking through the various resource files, the following file was found, '*app.asar*':

![1d3fec16751be560a7bb6ddaca0b5828.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/1d3fec16751be560a7bb6ddaca0b5828.png)

This revealed that the game was an electron app, and thus could be debugged using Chrome's devtools.

## Debugging the Game using Chrome's Devtools
Opening a command prompt within the folder containing the actual executable, the following command was ran:
```cmd
rubg.exe --remote-debugging-port=9992 --remote-allow-origins=*
```

After which, a Google Chrome browser was opened and the url `localhost:9992` was entered, allowing for the game to be debugged in real time:

![1c58246aeeaaec4ffda901179a598068.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/1c58246aeeaaec4ffda901179a598068.png)

The main chunk of backend code was found to be present in the *assets/index-c08c228b.js* file. There were many lines of code to go through and it was quite a struggle to identify where the code started. 

However, the problem had to be broken down logically into multiple steps, with the following critical questions:
1. How did the game assign the cells which were '1's (i.e. contained part of the battleships)?
2. How did the game check if the correct cell was hit?
3. Did the game check if the cells had to be hit in the correct order?

Answering the first question, the function *Hu()* which was responsible for generating the positions was found:

![6c917ec3348032f42cf0ac2db7543990.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/6c917ec3348032f42cf0ac2db7543990.png)

Tracing to where this function was called, it was found within this *E()* function:

![075e5b515690430af860aac5696c7cc8.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/075e5b515690430af860aac5696c7cc8.png)

Breakpoints and watch values could now be set, to observe what values *x* and subsequently *t.value* were assigned. When the game was first started, *x* was assigned an array of 32 elements, while *t.value* was assigned an array of 16 elements after the function *f(x)* was performed:

![74a8ab3beac803d865aed177431a77c7.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/74a8ab3beac803d865aed177431a77c7.png)

![32bf77bb4b6e510f4096c20c6c5e4ff3.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/32bf77bb4b6e510f4096c20c6c5e4ff3.png)

![c0d9e12450dd2bd3be0d4ef09e4e557b.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/c0d9e12450dd2bd3be0d4ef09e4e557b.png)

Seeing this, it appeared that the array of 32 elements was converted to an array of 16 elements, by concatenating every pair of elements. With that, an array of 16 integers was formed, which hinted that this could be the positions of the cells containing parts of the ships!

## Attaining Victory (unless...?)

Being very excited, a python code was written to convert these integers to binary strings. For example:
```python
array = [
    0,
    0,
    0,
    0,
    0,
    0,
    512,
    512,
    512,
    512,
    577,
    65,
    64,
    66,
    26,
    2
]

binary_array = []
for num in array:
    binary_str = bin(num)[2:]
    binary_str = binary_str.zfill(16)

for i, binary_str in enumerate(binary_array):
    print(f"{binary_str}")
```

This code would output the following:

![62143c0dc7a4f5e0df685bbf61254f45.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/62143c0dc7a4f5e0df685bbf61254f45.png)

This seemed like a grid where all the '1's represented correct positions while '0's represented the wrong positions. However, to much dismay, when testing out these positions, they kept returning the *DEFEAT* screen as well:

![bc941f92e87cec4eea30a72729c8f71e.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/bc941f92e87cec4eea30a72729c8f71e.png)

This meant that the game had another function to manipulate the position of ship cells, so the game was debugged further, and the following function was observed:

![b959e7c5f547fd959e7331bcde65faf4.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/b959e7c5f547fd959e7331bcde65faf4.png)

It appeared that the function *m(y-1)* was responsible for the checking of 'hit' or 'miss', thus the values of *y* was set to be watched and the function was analysed:

![06fb99b2a6d14201f46c6063b3ae5367.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/06fb99b2a6d14201f46c6063b3ae5367.png)

This function brought us to yet another function, *d(x)*, as only if *d(x)* returned true, the function *m(x)* would proceed further:

![0d8ca80fead35d85cc5aee35ee82f4d0.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/0d8ca80fead35d85cc5aee35ee82f4d0.png)

Also, it was found that *y* represented which cell was clicked at each point in time, counting from top left to bottom right- meaning that the top left most cell would result in *y* = 1, while if the cell at the last row, 2nd from the left was clicked, *y* = 241.

## Actually Attaining Victory

Thus, inspecting *d(x)*, the following check: `t.value[Math.floor(x / 16)] >> x % 16 & 1` indicated that the individual binary strings in the *t.value* array were actually checked from right to left, not left to right! This is because the right shift (>>) operation was used instead of the left shift operation when determining the column number via the operation *x % 16*. Meaning that for the earlier python code, each binary string had to be reversed, giving rise to the following modified code:
```python
binary_array = []
for num in array:
    binary_str = bin(num)[2:]
    binary_str = binary_str.zfill(16)
    reversed_binary_str = binary_str[::-1]
    binary_array.append(reversed_binary_str)
```

Testing this new code out, and clicking every correct cell, a *VICTORY* was obtained:
![ee7a085adadef9e1ab76dece6e6461c4.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/ee7a085adadef9e1ab76dece6e6461c4.png)

However, this victory was not a FLAWLESS one, thus the flag was not revealed.

## The FLAWLESS Victory
To obtain the FLAWLESS victory, the code was inspected further to analyse where this check was performed. However, it was not easy as the code was obfuscated (in some sense). Still, there was some hint within the code as the word *flag* could be found and this hinted that the previous condition had to be met in order for the flag to be revealed:

![dde970b349549f2b20bb4523a805d73f.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/dde970b349549f2b20bb4523a805d73f.png)

The condition that had to be satisifed was:
```java
c.value.push(`${n.value.toString(16).padStart(16, "0")[15 - x % 16]}${r.value.toString(16).padStart(16, "0")[Math.floor(x / 16)]}`),
                t.value.every(_=>_ === 0))
                    if (JSON.stringify(c.value) === JSON.stringify([...c.value].sort()))
```

This indicated that there was some sort of 'correct' order of clicking the cells involved, where the values '*n.value*' and '*r.value*' were used to determine the correct order of cells hit. These values were assigned after *t.value* was assigned:

![25f76f07c77b3597412a48df80980780.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/25f76f07c77b3597412a48df80980780.png)

Given the watchpoint set for the value of x, these values could easily be determined. After painstakingly analysing how the code worked, how the correct order of cells were determined was found to work in this way: 
1. *n.value* and *r.value* were converted to hex strings (padded with '0's at the start if less than length 16)
2. Based on the value of *x*, which was equal to *y-1*, one of the characters of the hex string was chosen from each of the hex strings and concatenated together to form a pair of hex characters
3. At the end of all cells being clicked, if the order of all pairs of hex characters was equal to the order of hex characters sorted in ascending order, then the condition `if (JSON.stringify(c.value) === JSON.stringify([...c.value].sort()))` was satisfied

To illustrate this, a code was written in python to determine all pairs of hex character generated in this way:
```python
import math

array = [
    0,
    0,
    0,
    0,
    0,
    0,
    512,
    512,
    512,
    512,
    577,
    65,
    64,
    66,
    26,
    2
]

hex_string1 = hex(15522563499221184705)[2:].zfill(16)
print(hex_string1,"\n")
hex_string2 = hex(13702099670151747825)[2:].zfill(16)
print(hex_string2,"\n")

binary_array = []
for num in array:
    binary_str = bin(num)[2:]
    binary_str = binary_str.zfill(16)
    reversed_binary_str = binary_str[::-1]
    binary_array.append(reversed_binary_str)

for i, binary_str in enumerate(binary_array):
    print(f"{binary_str}")

calculated_values = []
coordinates = []

j = 0
for binary_str in binary_array:
    value = "" 
    for i,bit in enumerate(binary_str):
        if bit == '1':           
            string_temp = str(j+1) + "," + str(i+1)
            coordinates.append(string_temp)
            char1 = hex_string1[15-i]
            char2 = hex_string2[j]
            value += char1 + char2
            calculated_values.append(value)
            value = ""
    j += 1

print(calculated_values)
sorted_calculated_values = sorted(calculated_values)
print(sorted_calculated_values)
print(coordinates)

combined_arrays = list(zip(calculated_values, coordinates))

sorted_pairs = sorted(combined_arrays, key=lambda x: x[0])

sorted_array2 = [pair[1] for pair in sorted_pairs]

print(sorted_array2)

j = 0
for binary_str in binary_array:
    for i, bit in enumerate(binary_str):
        if bit == '1':           
            string_temp = str(j+1) + "," + str(i+1)
            index = sorted_array2.index(string_temp)
            if index == 0:
                binary_str = binary_str[:i] + 'S' + binary_str[i + 1:]
            else:
                hex_index = hex(index)[2:].upper()
                binary_str = binary_str[:i] + hex_index + binary_str[i + 1:]
    binary_array[j] = binary_str
    j += 1

for i, binary_str in enumerate(binary_array):
    print(f"{binary_str}")
```

For example, given the starting *t.value* array (found in the code), the corresponding binary string array would be:

![e1ced97aaf592aa141fb29c970568cde.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/e1ced97aaf592aa141fb29c970568cde.png)

Furthermore, given *n.value* = 15522563499221184705 and *r.value* = 13702099670151747825, the following hex strings could be computed:
`d76b3942ae85f0c1`
`be27a30d9c6458f1`

Taking the first '1' that appears (from top left to bottom right) as an example, which would be found on the 7th row and 10th column (counts starting from 1), the pair of hex characters that would be formed would be: `40`, as `15 - x % 16 = 6` (once again, column was counted from the right) and `Math.floor(x/16) = 6`. Thus, the following hex characters were chosen (indicated in [ ])
`d76b39[4]2ae85f0c1`
`be27a3[0]d9c6458f1`

Finally, all pairs of hex characters could be printed and ordered in an ascending order, and sorting the respective coordinates of cells to click, the following order could be followed to attain a flawless victory:
![6086e15f4bb7bbc2cac38b1c097ce8ae.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/6086e15f4bb7bbc2cac38b1c097ce8ae.png)

However, to make it even easier to follow visually, the '1's in the initial array of binary string were replaced with the order that they had to be clicked, from 'S" (start) to F (15 in hexadecimal):
![9a92fb1ba29ca026b25b46cd3aa8eea6.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/9a92fb1ba29ca026b25b46cd3aa8eea6.png)

Following this order, a FLAWLESS victory was obtained giving the flag!
![e327450f744d63de5ed551238a7e8ea0.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/e327450f744d63de5ed551238a7e8ea0.png)
<br>

***
# 5. PALINDROME's Invitation
Domain(s): OSINT, Misc

![196345365c1839354272f33ee541bcee.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/196345365c1839354272f33ee541bcee.png)

> This challenge was an OSINT, Misc challenge, where we were given a web link to try and enter a secret chat room

## Looking through GITHUB Repository
![f54c1fa52909e8d81fa1c55eb14c3f5e.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/f54c1fa52909e8d81fa1c55eb14c3f5e.png)
![d1bd71dafcce2b63ce5c60dc05c5785e.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/d1bd71dafcce2b63ce5c60dc05c5785e.png)

Looking through the *Code* section of the github repository, there was a single file present, *test_portal.yml* that contained a test of the palindrome portal, containing some secret URL and password to enter the portal.

Looking through the *Pull requests* section, there seemed to be many pull requests from other users that were attempting to trigger a certain action to reveal the secret URL and password.
![575070893f4f507aa49ad69fae56117f.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/575070893f4f507aa49ad69fae56117f.png)

However, taking a look at the *Actions* section, the following test was found, which appeared to contain IP addresses and what seemed to be a password, appended to the back of the url (`:dIcH:..uU9gp1%3C@%3C3Q%22DBM5F%3C)64S%3C(01tF(Jj%25ATV@$Gl`)
![83ae9af537b9c8f1f8c5d8e73b17cedb.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/83ae9af537b9c8f1f8c5d8e73b17cedb.png)

The IP `http://18.143.207[.]255:45938` was visited, where this page appeared: 
![b8dbbbd2258103e0181ac254ee2fdd8b.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/b8dbbbd2258103e0181ac254ee2fdd8b.png)

The password `:dIcH:..uU9gp1%3C@%3C3Q%22DBM5F%3C)64S%3C(01tF(Jj%25ATV@$Gl` was submitted, but it was found to be wrong. However, on further inspection, it seemed to be URL encoded, thus URL decoding was performed to `:dIcH:..uU9gp1<@<3Q"DBM5F<)64S<(01tF(Jj%ATV@$Gl` and it was submitted. It turned out to be the correct password!

![e2f9ad2c489616de48571f3aec016a35.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/e2f9ad2c489616de48571f3aec016a35.png)

Clicking the *Welcome!* button, an invite to join 'PALINDROME's secret chat room appeared. However, after accepting the invite, no messages could be sent nor seen:
![a71918e4e604424958fa12cf50745d22.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/a71918e4e604424958fa12cf50745d22.png)

![ad2863e6b739abaf0d2d3c1419e47514.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/ad2863e6b739abaf0d2d3c1419e47514.png)

Trying to look for further hints on what to do, the password was attempted to be decoded further.

Thanks to CyberChef, the string was easily decoded with From Base85, to produce the string, "*PALINDROME has an AUTOMATED secretary*":
![ae2effca25e48415040ec0f75c88f284.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/ae2effca25e48415040ec0f75c88f284.png)

The *Welcome!* webpage was also inspected, revealing a string of hexadecimal digits, hinting that it could be a token of sorts:
![0907cc488029b415925f48c718b47be5.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/0907cc488029b415925f48c718b47be5.png)

Combining these 2 clues, it became apparent that we were given a token for a Discord bot that be interacted with to try and obtain the flag.

## Interacting with Discord Bot using Python API

This was done using the `discord` API in python. A few steps had to be done, namely:
1. Determining if the correct guild could be found
2. Determining permissions that the bot had within the server
3. Determining the number of channels in the server (also known as 'guild' in the context of the API)
4. Determining permissions that the bot had within each channel of the server
5. Figuring out how to obtain the flag, given the limited permissions of the bot

For step 1), the following code was first run, where the correct server was identified:
```python
import discord
from discord.ext import commands
TOKEN = 'MTEyNTk4MjI1OTAzNjU3Mzc5Ng.GhRMZn.oKg3NvlAdqe0oOao1lg7_kUwW4osEVLl4NorrE'

from discord.ext import commands

intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix="", intents=intents)  # No command prefix

@bot.event
async def on_ready():
    for guild in bot.guilds:
        print(f"Guild Name: {guild.name} (ID: {guild.id})")

bot.run(TOKEN)
```

![46d541d58d460e2f09649cc42aa46058.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/46d541d58d460e2f09649cc42aa46058.png)

Next, for steps 2), 3) and 4), these lines of code were added within the `async def on_ready()` function:
```python
if guild.name == "PALINDROME's secret chat room":
	bot_member = guild.get_member(bot.user.id)
	permissions = bot_member.guild_permissions
	for permission, value in permissions:
		if value:
			print(f'{permission}:{value}')
	for channel in guild.channels:
		print(f"Channel in server ({guild.name}):{channel.name}':")  
		permissions = channel.permissions_for(bot_member)
		for permission, value in permissions:
			if value:
				print(f'{permission}:{value}')
```

![cabac5a412288dcdbba25572e1a9c450.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/cabac5a412288dcdbba25572e1a9c450.png)

This revealed the following:
- The bot had permissions to *view_audit_log*, *read_messages* and *read_message_history* in the server
- There were multiple text channels: *general*, *secrets*, *meeting-records* and *flag*
- However, in the *flag* channel, the bot only had permission to *view_audit_log*

Thus, the audit logs were viewed at an attempt to reveal the flag within the logs. Looking at the discord python API reference, the audit logs had the following attributes:
![8076c8ed6e0810e05668e86e6d717e24.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/8076c8ed6e0810e05668e86e6d717e24.png)

Thus, the following lines of code were added to extract the *user*, *action* and *target* attributes:
```python
async for entry in guild.audit_logs(limit=None):
	print(f"{entry.user.name} did {entry.action.name} to {entry.target}")
```

As the audit logs were quite long, the python code was piped to a text file. Among the audit logs, unfortunately no flag was found, however there were multiple links that appeared:
![7bf28875b4af171c41190f5661aa6a9f.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/7bf28875b4af171c41190f5661aa6a9f.png)

Leaving the channel and attempting (one-by-one) to join the server once again using these links, 1 of the links revealed to be a link where more permissions were awarded to the user who joined via that link. This allowed the messages in the *flag* channel to be read, revealing the flag!
![e56436f169b405c15c9870183413837d.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/e56436f169b405c15c9870183413837d.png)
<br>

***
# 6. The Chosen Ones
Domain(s): Web

![19602df917e41a9aa082db43a450d507.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/19602df917e41a9aa082db43a450d507.png)

> For challenge 6, there were 2 paths: a web challenge and an RE challenge. The web challenge was chosen, where we were given a link to infiltrate and see what we could find.

## Predicting the Next Seed
Upon visiting the given URL, we were greeted by a pseudo-random number generator where we tasked to submit the next correct number:
![fc2fa46477b4df8919aad88c92337ef1.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/fc2fa46477b4df8919aad88c92337ef1.png)
![fe4e1c0fbb8fcc4b84bb6a951d68df21.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/fe4e1c0fbb8fcc4b84bb6a951d68df21.png)

Inspecting the webpage, what seemed to be another token of sorts (referring to the previous challenge) appeared:
![77ed055a6ac99f0dc4218ae10c51a8f7.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/77ed055a6ac99f0dc4218ae10c51a8f7.png))

However, using Base32 to decode, it revealed to actually be php code which revealed how the random number was generated:
![03462acb60bcc1458128ca78b497c283.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/03462acb60bcc1458128ca78b497c283.png)
```php
function random() {
    $prev = $_SESSION["seed"];
    $current = (int)$prev ^ 844742906;
    $current = decbin($current);
    while (strlen($current) < 32)  {
        $current = "0".$current;
    }

    $first = substr($current, 0, 7);
    $second = substr($current, 7, 25);
    $current = $second.$first;
    $current = bindec($current);
    $_SESSION["seed"] = $current;
    return $current%1000000;
}
```

Converting this code to python for easier understanding, the following code was obtained:
```python
def random():
    prev = session["seed"]
    current = prev ^ 844742906
    current = bin(current)[2:].zfill(32)
    first = current[:7]
    second = current[7:]
    current = second + first
    current = int(current, 2)
    session["seed"] = current
    return current % 1000000
```

Analysing the code, it appeared to be doing the following:
1. It took in the current *SEED* value which could not be observed (as it was found at the server side)
2. Performed an XOR operation with a fixed constant `844742906`
3. Converted it to a binary string and padded it with '0's to form a 32-bit binary
4. Swapped the places of the first 7 bits with the last 25 bits of the 32-bit binary
5. Assigned that value to be the new value of the seed
6. Returned the modulo of 1000000 of that value 

Given that the modulo operation was not a one-to-one function, but rather a many-to-one function (i.e. multiple inputs could result in the same output), the value of the new seed could not be easily determined just by observing the new seed value.

For example, for an equation such as: `x % 10 = 5`, the value of *x* could be 5, 15, 25, 35, etc. (there are infinite possible solutions)

However, for this case, there wasn't an infinite number of possible inputs, as it was given that the *SEED* value was at most a 32-bit integer. Calculating $$ 2^{32} $$, this equated to 4,294,967,296, which was the biggest possible *SEED*. 

Given 2 results which were known, the current seed could be determined by enumerating all possible values of the previous seed and checking against the 1st result. After knowing the current seed, the next result could be easily determined. This was achieved using the following python code (*random()* function as above):

```python
## Initialise random seed
session = {"seed": 123456789}

## Key in result1 and result2 observed from webpage:
result1 = int(input("Enter result1: "))
result2 = int(input("Enter result2: "))

for i in range(4295):
    prev = result2 + i*1000000
    prev = bin(prev)[2:].zfill(32)
    first = prev[:25]
    second = prev[25:]
    prev = second + first
    prev = int(prev,2)
    prev = prev ^ 844742906
    if prev % 1000000 == result1:
        session["seed"] = result2 + i*1000000
        print("Next result:",random())
```

![508c2bd029d32c5380a4c5893e4b60e9.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/508c2bd029d32c5380a4c5893e4b60e9.png)

Entering the correct number, we are brought to a new webpage, where a form with 2 fields and a table appeared:
![766353774439c2332a5596897bccf6d2.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/766353774439c2332a5596897bccf6d2.png)

## SQL Injection of a Partial Cookie
Initial thoughts were to perform SQL injection of the 2 fields, "First name" and "Last name". `sqlmap` was even used, although it seemed like these 2 fields were not injectable.

Inspecting the webpage cookies, it was found that there was a part of the cookie, *rank*, which could be manipulated and give rise to different table results being printed:
![0f16cc1abd1b900fbb237d8d86b51530.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/0f16cc1abd1b900fbb237d8d86b51530.png)

When rank was changed to 9:
![8d3981804030e82b4390b1884f7bbaf6.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/8d3981804030e82b4390b1884f7bbaf6.png)

Thus, SQL injection was attempted on this *rank* field instead, to determine if it was injectable. `sqlmap` was run once again, with the following command: 
```bash
sqlmap -u 'http://chals.tisc23.ctf.sg:51943/table.php' --cookie='rank=*; PHPSESSID=dfcrbqt1ius379rt55rmk2fbo4' -p 'rank' --param-filter='COOKIE' --level=2
```

![fe2120bd60e4ff20e05de81f6b42a5c9.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/fe2120bd60e4ff20e05de81f6b42a5c9.png)

It was observed that this field was indeed injectable! 

Little did I know of the powers of `sqlmap` and that it was able to print out all all entries from all tables, I went on to painstakingly understand SQL injections better and crafted manual SQL injections to:
1. Determine table schemas
2. Determine table names in the schema of interest
3. Determine column names of the table of interest
4. Print out entry in the column of interest

I treated this as a good learning lesson on understanding how to craft the SQL injections, rather than simply relying on the `sqlmap` tool:
I replaced the value of *rank* in the cookie to the respective values:
1. `-1 UNION SELECT table_schema, NULL,NULL,NULL FROM information_schema.tables--`

This revealed 3 schemas, with the 'palindrome' schema being of interest:

![3b449f94e89b9b77a8938e254c0b016c.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/3b449f94e89b9b77a8938e254c0b016c.png)

2. `-1 UNION SELECT table_name, NULL,NULL,NULL FROM information_schema.tables WHERE table_schema='palindrome'--`

This revealed that there was a table named *CTF_SECRET*

![24ff6d7a250385dac74da8cb2c248942.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/24ff6d7a250385dac74da8cb2c248942.png)

3.`-1 UNION SELECT column_name, NULL,NULL,NULL FROM information_schema.columns WHERE table_name='CTF_SECRET'--`

This revealed a column named *flag*

![a295d59fc94c8d448dd4ca089f8d0181.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/a295d59fc94c8d448dd4ca089f8d0181.png)

4. `-1 UNION SELECT flag, NULL,NULL,NULL FROM CTF_SECRET--`

This revealed the contents of the *flag* column, which only had 1 entry- the flag!

![d1bb7408ea35084fb322d99dadde6913.png]({{ site.url }}{{ site.baseurl }}/assets/images/TISC2023/d1bb7408ea35084fb322d99dadde6913.png)

{% if page.comments %}
<div id="disqus_thread"></div>
<script>
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://ravensics-github-io.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
{% endif %}

<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>